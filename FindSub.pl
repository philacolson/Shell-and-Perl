#! /usr/bin/perl
#TODO Why don't we just make this use a set union or subtract operation instead of matching each against a hash?
#This program removes bad contigs or retain good contigs from the *.data files generated by the Poly pipeline
#It can be used for other similar purposes

use Getopt::Std;
use strict;
#getopts effectively lets you treat a perl program like a shell program
getopts("C:c:t:i:o:d:n:f:m:rDh");
#opt_c is the file with the bad or good contigs list, one contig uid per line
#opt_C is the configuration file
#opt_D is the debug tag
#opt_r it to keep the rest records into another file
#opt_t is the type of the action: 0 for removal and 1 for retain. Default is 0 (removal).
#opt_i is the input file
#opt_o is the output file
#opt_d is the delimiter of the input file
#opt_n is the index of the contig field in the input file, starting from 0
#opt_f is the delimiter used in further split of the contig field to get the contig id. Default null
#opt_m is the index of the contig field in the further splitted fields, starting from 0
#opt_h prints help messages.

use vars qw(    $opt_c 
                $opt_C
                $opt_D
                $opt_t
                $opt_i
                $opt_o 
                $opt_d
                $opt_n
                $opt_f 
                $opt_m 
                $opt_r
                $opt_h
                );

my $delimiter = '\|'; #default delimiter of the input file
my $indexOfContig = 0; #default index of the contig field in the input file
my $furtherIndexOfContig = 0; #default index of the contig field in the further splitted fields
my $removeOrRetainType = 0; #default value for type: removal. 1 is for retain.
undef my (%contigHash);
undef my $contigID;
undef my $dumy;
undef my ($line);
undef my (@allFields);
undef my (@furtherFields);

if (defined $opt_h) {
  PrintUsage($0);
  exit(0);
}

if (not defined $opt_c) {
   #You need a -c (good/bad contig file)
  print "Must provide the bad or good contigs list file name as the -c option\n";
  PrintUsage($0);
  exit(0);
} 



open (LIST, "$opt_c") || die "Cannot open contig list file $opt_c\n";

while (<LIST>) {
   chomp;
   ($contigID, $dumy) = split; #[educated guess] We are probably only interested in the one column $contigID, and the $dumy is a DUMMY variable
#create a new hash under $contigHash and make the key $contigID and the value 1
   $contigHash{$contigID} = 1;  #store this contig id into hash
}
close LIST;

if (defined $opt_C) {
#makes the config file called, appropriately, CONFIG
  open (CONFIG, "$opt_C") || die "Cannot open confir file $opt_C\n";
  while (<CONFIG>) {
    chomp;
#####use of ampersand deprecated, change?

    &GetConfig($_);
    if (defined $opt_D) {
       &ProcessFileWithDebug();
    } else {
       &ProcessFile();
    }
  }
  close CONFIG;
} else {
  &CheckOptions();
  if (defined $opt_D) {
     &ProcessFileWithDebug();
  } else {
     &ProcessFile();
  }
}

sub GetConfig(@) {
   my $configLine = shift;#Grabs the first item in the array and assigns it to configLine
   my @configs = split(/:/, $configLine);#everything separated by a colon gets its own array slot
   my @options;
   my $config;

   #initialize all options
   undef $opt_i;
   undef $opt_o;
   $opt_d = $delimiter;
   $opt_n = $indexOfContig;
   undef $opt_f;
   $opt_m = $furtherIndexOfContig;
   

#cycle through all the entries from the @configs array, assigning the input to the appropriate variable
   foreach $config (@configs) {
      @options = split(/\s/, $config);#split the individual array slot by a space to separate the option with the value
      if ($options[0] =~ /-i/) {
         $opt_i = $options[1];
      } elsif ($options[0] =~ /-o/) {
         $opt_o = $options[1];
      } elsif ($options[0] =~ /-r/) {
         $opt_r = 1;
      } elsif ($options[0] =~ /-t/) {
         $opt_t = $options[1];
      } elsif ($options[0] =~ /-d/) {
         $opt_d = $options[1];
      } elsif ($options[0] =~ /-n/) {
         $opt_n = $options[1];
      } elsif ($options[0] =~ /-f/) {
         $opt_f = $options[1];
      } elsif ($options[0] =~ /-m/) {
         $opt_m = $options[1];
      } elsif ($options[0] =~ /-n/) {
         $opt_n = $options[1];
      }
   }
#Makes sure it has all the option entries it needs
   &CheckOptions();

##   print "opt_o is **$opt_o**\n";
##   print "opt_r is **$opt_r**\n";
##   print "opt_t is **$opt_t**\n";
##   print "opt_d is **$opt_d**\n";
##   print "opt_f is **$opt_f**\n";
##   print "opt_m is **$opt_m**\n";
##   print "opt_n is **$opt_n**\n";

   return;
}

sub ProcessFileWithDebug() {
  open (IN, "$opt_i") || die "Cannot open input file $opt_i\n";
 #for each line in the input file
  while($line = <IN>) {
    chomp($line);
#grabs all the fields individually by splitting it with the delimiter provided
    @allFields = split(/$opt_d/, $line);

    for (my $index = 0; $index <= $#allFields; $index++) { #for every field,
      print "field $index: **$allFields[$index]**\n"; #number and say the field
    }

    $contigID = $allFields[$opt_n];#opt_n is the offset for the contig field
    print "contig after first index is **$contigID**\n";

    if (defined $opt_f) {#opt_f is any further delimiter needed to break down the contig field into just the contig
       @furtherFields = split(/$opt_f/, $contigID);
       $contigID = $furtherFields[$opt_m]; #opt_m is the index of the further broken down contig field to get the contig
       print "contig after the second index is **$contigID**\n"; #prints the contig after being broken down
    }
    if (defined $contigHash{$contigID}) {#if there is already a hash for the contig
        print "In list: $line\n";#say where it is
    }
  }
  close IN;
}

sub ProcessFile() {
  open (IN, "$opt_i") || die "Cannot open input file $opt_i\n";
  open (OUT, "> $opt_o") || die "Cannot write output file $opt_o\n";
  if (defined $opt_r) {
    open (REST, "> $opt_i.rest") || die "Cannot write output file $opt_i.rest\n";
  }
  
  while($line = <IN>) {
    chomp($line);
    @allFields = split(/$opt_d/, $line); #grabs all the fields individually by splitting it with the delimiter provided
  
    $contigID = $allFields[$opt_n];#opt_n is the offset for the contig field
    #print "contig here is $contigID\n";
    if (defined $opt_f) {#opt_f is any further delimiter needed to break down the contig field into just the contig
       @furtherFields = split(/$opt_f/, $contigID);
       $contigID = $furtherFields[$opt_m];#opt_m is the index of the further broken down contig field to get the contig
    }
  
    #print "contig now is $contigID\n";
    #sleep(1);
  
if ((not defined $opt_t) || ($opt_t == 0)) { #for removal: default is removal
     if (not defined $contigHash{$contigID}) {	#if there is no hash for the contigID, print it to the output file
          print OUT "$line\n";
     } 
     else {
          print REST "$line\n";#otherwise print it to the REST file
     }
}
 
else { #for retain
     if (defined $contigHash{$contigID}) { #if there IS a value for the contigID key, print the line to OUT.
          print OUT "$line\n";
     }
     else {
          print REST "$line\n"; #otherwise, there is not a key, print it to REST.
     }
} 
}
  close IN;
  close OUT;
  if (defined $opt_r) {
    close REST;
  }
}

######################################################################
#Module:      CheckOptions()
#
#Description: This module checks the options provided from the command,
#             line, and open the files specified in the options
#
#             Input:  null
#
#             Output: null
######################################################################
sub CheckOptions() {
  if (not defined $opt_i) {
    print "Must provide the input file name as the -i option\n";
    PrintUsage($0);
    exit(0);
  } 

  if (not defined $opt_o) {
    $opt_o = "$opt_i.cleaned";
  } 

  if (not defined $opt_d) {
    $opt_d = $delimiter;
  }

  if (not defined $opt_n) {
    $opt_n = $indexOfContig;
  }

  if (not defined $opt_m) {
    $opt_m = $furtherIndexOfContig;
  }

  if (not defined $opt_t) {
    $opt_t = $removeOrRetainType;
  }

}
 
######################################################################
#Module:      PrintUsage(@)
#
#Description: This module prints the usage of the program
#
#             Input:  none
#
#             Output: none
#
#Assumptions:
#
######################################################################
sub PrintUsage(@) {

  print "\n  $0 Help: this program removes all bad contigs or retain good contigs
  from an input file generated from the Poly pipeline. It can be used for similar 
  purposes in other situations.

  Usage: $0 -c opt_c [-C opt_C | -i opt_i] [-o opt_o] [-t opt_t] 
         [-d opt_d] [-n opt_n] [-f opt_f] [-m opt_m] [-r] [-h]

  -c: the file with the bad or good contigs list, one contig uid per line
  -C: the configuration file specifying the options, separated by : and with -X formats
  -t: the type of action, 0 for removal and 1 for retain. Default is 0 (removal).
  -i: the input file
  -o: the output file: default, opt_i.cleaned
  -r: keep the rest records into a file called opt_i.rest
  -d: the delimiter of the input file (default '|')
  -n: the index of the contig field in the input file, starting from 0 (default 0)
  -f: the delimiter used in further split of the contig field to get the contig id (default null)
  -m: the index of the contig field in the further splitted fields, starting from 0 (default 0)
  -h: prints help messages.
";
}
